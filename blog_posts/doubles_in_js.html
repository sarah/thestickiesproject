As I've written before, when I first started testing javascript, I ran into some frustrations with the mocking framework bundled with blue-ridge. Some specific things were that neither method expectations/stubs nor html fixtures were being reset at the end of each example. I was used to the transactional nature of examples from my experience in both C# and Ruby, and this caught me a bit by surprise while starting out with javascript. For example, if my code added or removed a node in the html fixture, this structure remained when the next test was executed.

At first, this caused me a lot of consternation, as I was used to this behavior in other languages, such as C# and Ruby. So, I tried to listen to what my tests were telling me. It is difficult sometimes, though, to understand the message they have about your design. Not getting a full grasp, I did the only thing I know how to do: start stripping away the layers between me and the design. The first thing I bypassed was the pre-built mocking framework that is packaged with blue-ridge, smoke. And that brings us to this blog post's main topic: what have I learned and where am I headed (hint: I'm going to be extracting some of these learnings into a set of reusable tools soon). Some of these are specific to blue-ridge and some are just related to javascript, in general. Some of these are really cool, some are temporary steps on my way to learning better javascript design.

Test doubles are free

One beauty of javascript's prototype-based nature, as opposed to being class-based, is that the concept of 'type' really frees itself from the usual tight-coupling with 'class' that most people think of. A javascript object is this: {}. That's it. Nothing more than that. What type is it? Well, no real type, yet. Want to change the type of it? Add some behaviors, either by mixing in a new prototype or just add the individual behaviors, yourself. Using jQuery makes this very easy, as it has an extend function, which you can use to easily mix in behaviors. This allows you to very easily evolve the type of an object as it moves through it's lifetime.

What does this mean for test doubles? Well, you don't need anything other than {} to create yourself a test double. Need to stub out a behavior? Do something like

var double = {};
double.stubbedFunction = function() { return 5; }
functionUnderTest(double);

Because functions in javascript are closures, you can even do something like:

var double, returnValue;
returnValue = 5;
double = {};
double.stubbedFunction = function() { return returnValue; }
functionUnderTest(double);

Want to capture the arguments? That's easy, too:

var double, __args_stubbedFunction;
__args_stubbedFunction = 5;
double = {};
double.stubbedFunction = function() { __args_stubbedFunction = arguments; }
functionUnderTest(double);

I'll leave it as an exercise to the reader how to both capture the arguments and return a value. :)

Get away from the DOM as soon as possible

Even with great tools like jQuery, interacting with the browser blows big time. So, build a very thin layer at the entry points to your system, detach yourself from the actual dom by creating javascript object wrappers and manipulate those. This has a lot of benefits, including the usual ones gained from isolation. A lot of times, I hear people talk about javascript being all UI/view code. In the stickies project, we are putting the majority of our system in javascript, using the browser as an application platform. This means that we have view code and domain logic all running in there. So, as with any architecture, you should be isolating the UI and just testing the innards.

Side story: When I was first learning about test-first programming, I had to build a user interface for the automation tool I was writing. I was pairing with Bob Koss at the time, and I had come to work in the morning after struggling all night with the idea of writing tests for the user interface. I asked him about it, and he reinforced the rule that most people believe, but few people truly do: there should be no logic at all in your user interface. That is, the layer directly behind the UI should be receiving events, grabbing the data and sending it to the underlying logic components. I've been doing it religiously ever since. When you start moving heavily from test-first to test-driven, you really start to see that you can't do anything but isolate the user interface. After all, when your executable examples are treated as a client of your system, your UI will just be the second client, heavily relying on a well-defined api.

Object creation is cheap

In the stickies project, a sticky is represented on the screen by a div. Plugins, such as jQuery UI, interact with our system via the DOM, not via our javascript objects. So, why not have the div be the canonical 'sticky' object, spinning up javascript-based 'stickies' whenever we need them. Create a builder function that takes a div and returns a javascript object. However, we don't persist these javascript objects, they are built on an as needed basis, generally due to a stimulus from a user event, then thrown away when we are done reacting to the event. This also allows us to easily test our functionality by passing in dummy objects that we create in our tests. Yeah, we could use jQuery to spin up some dummy dom elements, but then you have a lot of unnecessary cruft around.

As I've been spinning my own doubles, I'm starting to notice a few patterns begging to be extracted. Stubbing a function with a given return value and collecting the arguments given is a common task. It is the most common activity that I do. I occasionally do it on existing objcts, but most of the time it is on doubles that I've spun up to pass in. I've allowed the duplication to persist for a while, trying different techniques, but I've pretty much settled on the one. This means that it is time to extract it. I'll be pulling this into a separate library and putting it up on github.

There are other things I've learned, but I want to end this and get it posted. We are doing our best to post regularly, so you can expect more thoughts on javascript while we continue to build the stickies project. We are close to initial feature complete, so a beta release is on the horizon. No specific date, yet, but it will be soon.

MOVED INTRO STORY
I've been doing test-driven development for a reasonable amount of time now, around 6 years. I started in C#, then moved to Ruby, dabbling a bit here and there in other languages, like Java and Python, seeing how people were working in those environments. While I had written a fair amount of code in javascript, I had never really put the effort into learning how to be effective at testing it. Forget about TDD, I wasn't at all experienced at how to do test-first. So, as I've outlined before, I took the stickies project to fill that gap in my knowledge. I downloaded blue-ridge, read the documentation for screw.unit and smoke, then dove right in. My experience with doing TDD in other languages gave me a bit of a jumpstart, so I thought I'd be good to go. I'm working on a finishing the series on how TDD influenced my javascript designs, but I wanted to talk about a very specific aspect of my style of TDD. You see, I'm an isolationist; some people call it 'london-style.' I use a lot of fakes....mocks....doubles....stubs....however you want to use and name them. In the end, I isolate my code from its dependencies in order to provide specific examples of how that code behaves under explicitly described circumstances. And that is where I struggled with the smoke framework.

As I've written before, I did not have a great experience using the smoke javascript mocking framework. This isn't a rant about smoke, though, as, honestly, I chalk it up to my lack of experience with designing in javascript, bringing over incompatible habits from other languages. But, here was my dilemma: I didn't have a lot of experience with driving my design in javascript, and so I was feeling a lot of pain with a mocking framework, but, how to get the experience. Let's go back to my early days of TDD in C#.

I started doing test-driven development in 2004, after having the extremely fortunate opportunity to be on the team that received an xp immersion training from Object Mentor. So, Uncle Bob came in and helped, Lowell Lindstrom was there, Michael Feathers helped out, and I got to spend a significiant amount of time pairing with Bob Koss. It wasn't long before I was absolutely hooked, and, after they left, I continued practicing, writing as much of my code as possible test-first. I wasn't ready to really understand what the tests were trying to tell me about my design, so I was doing a mixture of up-front, just-in-time design with test-first techniques; it would be a while before I had the experience to really fall into a pure test-driven approach, but that is a story for another time. This is the story of my history with test doubles and javascript.

So, when I started writing test-first in C#, I hand-rolled by own fakes. I wasn't totally aware of all the intricacies, I just wrote them as I needed them. Did I intend one to return something, then I implemented the method to return something. Need to check if it gets called with specific arguments, implement the method to keep track of the argument I'm interested in, then I would check it after I called the method I was testing. Pretty quickly, I started noticing patterns in the code. In fact, the duplication between my tests was starting to get so bad, I could almost hear it screaming. So, I started removing it, slowly pulling out a reusable set of tools that I could employ to rapidly create myself a hand-rolled fake whenever I need one. I noticed that my design style lent itself well to setting expectations on the collaborator objects, so my tools allowed me an easy way not only to check which methods were called, but which methods weren't and which were called unexpectedly. Often, the argument values, themselves, were important, so I included that capability. I seem to remember that I used this hand-rolled set of tools for about 7-8 months, slowly adding to it, as I noticed things I needed. I wasn't surrounded by a community of experienced test-driven development practitioners, so I was figuring this all out on my own. Eventually, though, I took a look around and noticed that there was another tool, called nmock, which I had basically implemented around 3/4 of without realizing it. Looking at that system, I realized it had all the functionality of my set of tools, plus a bit more, and it was being maintained by people. So, I switched to my first mocking framework. Along the way, though, I learned a lot about my own designs and design-style. I stumbled upon the idea of dependency injection and how it relates to inversion of control. As I moved towards listening to my tests, I started seeing my designs become much more decoupled, my objects and their behaviors much smaller and focused. Because I was hand-rolling my own fakes, I felt the pain associated with breaking encapsulation and how it related to the Law of Demeter. By the time I switched to a framework, I was at the beginning of establishing some base practices that would stick with me to this day.

